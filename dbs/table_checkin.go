package dbs

import (
	"errors"
	"game-mining-server/configs"
	"game-mining-server/utils"
	"github.com/google/uuid"
	"gorm.io/gorm"
	"time"
)

type Checkin struct {
	Id             string `gorm:"primaryKey;type:varchar(255)" json:"id"` // unique id, generated by uuid4
	Uid            int64  `gorm:"primaryKey;type:bigint" json:"uid"`      // checkin user id
	CreatedAt      int64  `gorm:"autoCreateTime:milli" json:"createdAt"`  // created ts: 1670400478555
	UpdatedAt      int64  `gorm:"autoUpdateTime:milli" json:"-"`          // updated ts: 1670400478555
	ContinuousDays int    `gorm:"type:int" json:"continuousDays"`         // continuous day counter
	RewardPoint    int64  `gorm:"type:bigint" json:"rewardPoint"`         // rewardPoint for this continuous checkin
	Status         int    `gorm:"type:int" json:"status"`                 // checkin status: 0: unclaimed, 1: claimed
}

func (u *Checkin) TableName() string {
	return "checkins"
}

// CheckinFindByUid find a user's checkin by uid
func (s *Service) CheckinFindByUid(uid int64) (*Checkin, error) {
	var checkin Checkin
	if e := s.DBInstance.Where("uid = ?", uid).First(&checkin).Error; e != nil {
		return nil, e
	} else {
		return &checkin, nil
	}
}

// CheckinGetLatestCheckin get latest checkin res for specified user
func (s *Service) CheckinGetLatestCheckin(db *gorm.DB, uid int64, basicConfig *configs.BasicConfig) (*Checkin, error) {
	baseTimeTs := getBaseTimeTs(basicConfig)
	var latestCheckin Checkin
	// find last latest checkin
	if e0 := db.Where("uid = ?", uid).Order("created_at desc").First(&latestCheckin).Error; e0 != nil {
		if errors.Is(e0, gorm.ErrRecordNotFound) {
			// no latest check record, do a checkin and start a new continuous sequence
			return createCheckin(db, uid, 1)
		} else {
			return nil, e0
		}
	}
	if latestCheckin.CreatedAt >= baseTimeTs {
		// already checkin today (since baseTime, found a checkin record), if already claimed, return nil, otherwise return checkin
		if latestCheckin.Status == configs.CheckinStatusClaimed {
			return nil, nil
		} else {
			return &latestCheckin, nil
		}
	} else if latestCheckin.CreatedAt < baseTimeTs-int64(basicConfig.CheckinBrokenSec*1000) {
		// last checkin before more than baseTime + brokenDuration, start a new continuous sequence
		return createCheckin(db, uid, 1)
	} else {
		return createCheckin(db, uid, latestCheckin.ContinuousDays+1)
	}
}

func getBaseTimeTs(basicConfig *configs.BasicConfig) int64 {
	if basicConfig.Env == configs.EnvPROD {
		return utils.GetUTC0Ts()
	} else {
		return time.Now().UnixMilli() - int64(basicConfig.CheckinBrokenSec*1000)
	}
}

func createCheckin(db *gorm.DB, uid int64, continuousDays int) (*Checkin, error) {
	newCheckin := &Checkin{
		Id:             uuid.New().String(),
		Uid:            uid,
		ContinuousDays: continuousDays,
		RewardPoint:    utils.CalPointForDailyCheckin(configs.CheckinBaseRewardPoint, continuousDays),
		Status:         configs.CheckinStatusUnclaimed,
	}

	if e := db.Create(newCheckin).Error; e != nil {
		return nil, e
	} else {
		return newCheckin, nil
	}
}
